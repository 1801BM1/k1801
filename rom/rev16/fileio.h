//
// Модуль:          заголовочный файл для процедур работы с файлами
//
#ifndef __FILEIO_H__
#define __FILEIO_H__

//
// Определение типов поддерживаемыъ файлой
// Если соответствующий тип файла закомментирован,
// то для не будет генерироваться код процедур поддержки
//

#define FLTYP_BIN       0x00000001L     // двоичный файл
#define FLTYP_HEX       0x00000002L     // формат Intel Hex Extended

#define FLFLG_ForWrite  0x00000001L     // файл был открыт для записи

#define FL_ERR_SUCCESS  0x00000000L     // все прошло успешно
#define FL_ERR_WRITE    0xFF000100L     // ошибка записи файла
#define FL_BUFSIZE      0x6000          // размер буфера файла
#define FL_LINSIZE      256             // максимальная длина строки
                                        // включая конечный нуль

#define FL_HEXSIZE      16              // размер выходной записи hex-файла
#define DIAG_PAGE_SIZE  256             // размер блока считывания/записи
                                        // и вывод диагностической информации

//
// Диагностические сообщения процедур чтения/записи файлов
//
#define FLMSG_READHEX       "\nLoading input file     : 000000"
#define FLMSG_WRITEHEX      "\nSaving output file     : 000000"
typedef struct _FHANDLE
{
    //
    // Сейчас предполагается однопоточная модель, при многопоточной
    // модели в эту структуру можно добавить объекты синхронизации
    //
    int     Handle;         // хендл открытого файла
    PBYTE   Ptr;            // текущий указатель данных
    PBYTE   End;            // конец порции данных в буфере
    DWORD   Size;           // размер буфера в байтах
    DWORD   Flags;          // флажки открытого файла
    BYTE    Data[1];        // собственно данные буфера
} FHANDLE, *PFHANDLE;

//
// Открывает указанный файл исключительно для чтения
// Возвращает открытый хендл или NULL в случае ошибки
// При открытии специфицируется размер буфера для чтения
//
PFHANDLE FL_Open(char* Name, DWORD BufSize);

//
// Открывает указанный файл исключительно для записи
// Возвращает открытый хендл или NULL в случае ошибки
// При открытии специфицируется размер буфера для записи
//
PFHANDLE FL_Create(char* Name, DWORD BufSize);

//
// Производит чтение указанного числа байтов из файла
// Возвращает число реально прочитанных байтов,
// 0 - в случае конца файла или ошибки чтения
//
DWORD FL_ReadArray(PFHANDLE File, PBYTE Data, DWORD Count);

//
// Производит чтение одного байта из файла
// Возвращает < 0 - в случае конца файла или ошибки чтения
//                  иначе возвращает прочитанный байт
//
int FL_ReadByte(PFHANDLE File);

//
// Производит запись указанного числа байтов в файл
// В случае ошибки возвращает ненулевое значение
//
DWORD FL_WriteArray(PFHANDLE File, PBYTE Data, DWORD Count);

//
// Производит запись данных из буфера на диск, в случае
// ошибки выводит сообщение возвращает ненулевое значение
//
DWORD FL_Flush(PFHANDLE File);

//
// Функция закрытия открытого файла, если файл был открыт
// на запись, то происходит запись отставшихся данных на диск,
// также освобождается память, выделенная для буфера
//
void FL_Close(PFHANDLE File);

#ifdef FLTYP_BIN
//
// Функция сохранения буфера памяти в бинарном выходном файле
// При этом возможен вывод диагностических сообщений в
// установленном формате
//
BOOL FL_SaveBin(char*, PBUF, DWORD);

//
// Функция загрузки бинарного файла в указанный буфер памяти
// При этом возможен вывод диагностических сообщений в
// установленном формате
//
BOOL FL_LoadBin(char*, PBUF, DWORD);
#endif FLTYP_BIN

#ifdef FLTYP_HEX
//
// Функция сохранения буфера памяти в выходном hex-файле
// При этом возможен вывод диагностических сообщений в
// установленном формате
//
BOOL FL_SaveHex(char*, PBUF, DWORD);

//
// Функция загрузки hex-файла в указанный буфер памяти
// При этом возможен вывод диагностических сообщений в
// установленном формате
//
BOOL FL_LoadHex(char*, PBUF, DWORD);
#endif

#endif  __FILEIO_H__

